# ASP NET Web API

ASP.NET offers three frameworks
- Web Forms
- MVC
- Web Pages

ASP.NET Web API
- building RESTful applications on the .NET Framework

## ASP.NET Web API

Use HTTP methods.

Create a controller, which defines:
- `GetAllProducts` method returns an `IEnumerable<Product>` type, url `/api/products`.
- The `GetProduct` method: url `/api/products/id`.

Web API controller action can return
- void: no content 204.
- HttpResponseMessage: Convert directly to an HTTP response message.
- IHttpActionResult: Call `ExecuteAsync` to create an `HttpResponseMessage` from a factory, then convert to an HTTP response message.
- Some other type: Write the serialized return value into the response body; return 200.

Single-Page Applications (SPAs): the entire page is loaded in the browser after the initial request, but subsequent interactions take place through Ajax requests.

The Web API framework is part of the ASP.NET Stack and is designed to make it easy to implement HTTP services, generally sending and receiving JSON- or XML-formatted data through a RESTful API.

Entity Framework (EF) is an object-relational mapper (ORM) that enables you to create data access applications by programming with a conceptual application model instead of programming directly using a relational storage schema.

Initial the DB: in HTTPApplication, add `System.Data.Entity.Database.SetInitializer(new TriviaDatabaseInitializer());` to `Application_Start()`.

Global config like fommater and routes: `WebApiConfig`.

ASP.NET Scaffolding is a code generation framework for ASP.NET Web applications. The controller generated by it has
- inherit from `ApiController`.
- Context is the db of EF.
- override `Dispose` to release all the resource of Context instance.

Use Code Snippet to add help methods, for example AsyncTask.

Web API routing is very similar to MVC routing. The main difference is that Web API uses the HTTP method, not the URI path, to select the action.

Controller handles HTTP requests. The public methods of the controller are called action methods or simply actions.

When the Web API framework receives a request, it routes the request to an action. To determine which action to invoke, the framework uses a routing table: `WebApiConfig`.

convention:
- "/contacts" go to an MVC controller, and "/api/contacts" go to a Web API controller.
- Route request to Action whose name begins with that HTTP method name for GET, POST, PUT, and DELETE methods. 

Parameter Bindings: how Web API creates a value for a parameter.
- Simple types are taken from the URI.
- Complex types are taken from the request body.

Attribute Routing in Web API 2.
- solving the routing problem that resources often contain child resources.
- need decorating http methods: Delete, Get, Head, Options, Patch, Post, Put.
- need controller methods return a data transfer object (DTO) instead of the EF model. 

AJAX isn't new, but today there are JavaScript frameworks that make it easier to build and maintain a large sophisticated SPA application. This tutorial uses `Knockout.js`ã€‚
building blocks
- ASP.NET MVC creates the HTML page.
- ASP.NET Web API handles the AJAX requests and returns JSON data.
- Knockout.js data-binds the HTML elements to the JSON data.
- Entity Framework talks to the database.

"Code First" approach to EF: write C# classes that correspond to database tables, and EF creates the database.

Write domain objects as POCOs (plain-old CLR objects).

CRUD operations: Create, read, update and delete.

circular navigation properties: EF models can have navigation properties, which are another model. If both entities have reference to the other, a circular created. Use DTOs or change the JSON/XML formatters to solve the problem.

three ways to load related data in EF
- eager loading: load while init DB query, use `System.Data.Entity.Include`.
- lazy loading: automatically loads when the navigation property for that entity is dereferenced. make the navigation property virtual. It can cause serialization problems. Can serialize data transfer objects (DTOs) instead of entity objects to solve it.
- explicit loading: write personal codes to do lazy loading.

DTOs:
- change the database schema to return the client.
- Remove circular references.
- Hide particular properties.
- Flatten object graphs that contain nested objects.
- Avoid "over-posting" vulnerabilities: user posts some properties that are read-only/not exist.
- Decouple your service layer from your database layer.

Open Data Protocol (OData)
- a uniform way to query and manipulate data sets through CRUD operations.
- can have a v4 endpoint that runs side-by-side with a v3 endpoint.

In `Web.config`, add `connectionStrings` for setup the DB connection.

In `App_Start/WebApiConfig.cs`, update `Register` method to setup Entity Data Model (EDM) and route.
- Route setup endpoints.

The `[EnableQuery]` attribute enables clients to modify the query, by using query options such as $filter, $sort, and $page. 

OData supports two different semantics for updating
- `PATCH` performs a partial update. The client specifies just the properties to update.
- `PUT` replaces the entire entity.

Using OData, clients can navigate over entity relations. 

OData supports creating or removing reference(Odata4)/link(OData3), which is relationships, between two existing entities.

The URI of the reference: `http:/host/Products(1)/Supplier/$ref`
- PUT if the navigation property is a single entity.
- POST if the navigation property is a collection.

actions and functions are a way to add server-side behaviors that are not easily defined as CRUD operations on entities.
- actions have side effects but functions don't.
- actions can used to Complex transactions, Manipulating several entities at once, Allowing updates only to certain properties of an entity, Sending data that is not an entity.
- Functions are useful for returning information that does not correspond directly to an entity or collection.
- binding: An action (or function) can target a single entity or a collection. So it is an action for some entity.
- "unbound" actions/functions: static operations on the service. It is not for some specific entity.

A complex type is a structured type without a key.

[Service Metadata Document](https://docs.microsoft.com/en-us/aspnet/web-api/overview/odata-support-in-aspnet-web-api/odata-v3/creating-an-odata-endpoint#service-metadata-document)
- describes the data model of the service.
- using an XML language called the Conceptual Schema Definition Language (CSDL).
- The metadata document shows the structure of the data in the service, and can be used to generate client code.
- To get the metadata document, send a GET request to `http://localhost:port/odata/$metadata`.
- EntityContainer and EntitySet are defined if an entity can be get in groups.

To add an entity:
1. Create a class.
2. Set up Context class to make EF include the table.
3. Update csdl so client knows the data structure.
4. Write Controller codes to support CRUD.

`[FromOdataUri]` attribute in the key parameter: tells Web API to use OData syntax rules when it parses the key from the request URI.

links:
- uri: `entity/$links/entity`.

Generate Service Proxy for client
- proxy is a .NET class that defines methods for accessing the OData service.
- The proxy translates method calls into HTTP requests.
- setup uri.

Apply Query options
- use LINQ expressions.
- define a method.

`where` clause: GET `http://localhost/odata/Products()?$filter=Category eq 'apparel'`

`orderby` clause: GET `http://localhost/odata/Products()?$orderby=Price desc`

Client-Side Paging
- client might want to limit the number of results.
- `Skip` and `Take`: GET `http://localhost/odata/Products()?$orderby=Price desc&$skip=40&$top=10`

`DataServiceQuery<t>.Expand`: GET `http://localhost/odata/Products()?$expand=Supplier`

`select`: GET `http://localhost/odata/Products()?$select=Name`

A `select` clause can include related entities. In that case, do not call `expand`.

Query options: the parameters the client send in the query string.
- expand.
- filter: based on a boolean condition.
- inlinecount: include the total count of matching entities in the response. used for server-side paging.
- orderby.
- select.
- skip.
- top.

Need `EnableQuerySupport` in the startup `HttpConfiguration`, which enables Query options for any controller action that returns an IQueryable type. Or add `[Queryable]` attribute to the action method.

Filter example
- `http://localhost/Products?$filter=Category eq 'Toys'`
- `http://localhost/Products?$filter=Price ge 5 and Price le 15`
- `http://localhost/Products?$filter=substringof('zz',Name)`
- `http://localhost/Products?$filter=year(ReleaseDate) gt 2005`

[Server-Driven Paging](https://docs.microsoft.com/en-us/aspnet/web-api/overview/odata-support-in-aspnet-web-api/supporting-odata-query-options)
- `[Queryable(PageSize=10)]`
- response will have `"odata.nextLink":"http://localhost/Products?$skip=10"`
- client can see total number of results `http://localhost/Products?$inlinecount=allpages`

Allow ordering only by certain properties, to prevent sorting on properties that are not indexed in the database:
- `[Queryable(AllowedOrderByProperties="Id")]`

`Web.Http.OData.Query.Validators` can validate queries.

Expand example:
- `http://localhost/odata/Products(1)?$expand=Category,Supplier`

Web API limits the maximum expansion depth to 2, to avoid creating large responses.

You can combine `$select` and `$expand` in the same query. Make sure to include the expanded property in the `$select` option.
- `http://localhost/odata/Products?$select=Name,Supplier&$expand=Supplier`

select the properties within an expanded property, e.g. Name is Product property:
- `http://localhost/odata/Categories?$expand=Products&$select=Name,Products/Name`

Raw value of the property substruct the value:
- `http://localhost/odata/Products(1)/Name/$value` returns "Hat", but otherwise it will have odata.metadata includes.

When Web API gets an OData request, it maps the request to a controller name and an action name.

OData URI consists of
- The service root: `https://example.com/odata`
- The resource path: `/Products(1)/Supplier/`
- Query options: `?$top=2`

resource path is divided into segments.
- `Products`
- `1`
- `Supplier`

Controller name is the root of the resource path, which is `ProductsController`.

Action Name is the path segments plus the entity data model(EDM):
- `/Products`: GetProducts
- `Products(1)`: GetProduct
- `Products(1)/Models.Book`: GetBook
- `/Products(1)/Supplier` where Supplier is navigation property: GetSupplierFromProduct
- `/Products(1)/$links/Supplier`: CreateLink
- `/Products(1)/Name` where name is a property: GetNameFromProduct
- `/Products(1)/Rate` where Rate is an action: RateOnProduct

Method Signature rule:
- If the path contains a key, the action should have a parameter named key.
- If the path contains a key into a navigation property, the action should have a parameter named relatedKey.
- Decorate key and relatedKey parameters with the `[FromODataUri]` parameter.
- POST and PUT requests take a parameter of the entity type.
- PATCH requests take a parameter of type Delta<T>, where T is the entity type.

[examples](https://docs.microsoft.com/en-us/aspnet/web-api/overview/odata-support-in-aspnet-web-api/odata-routing-conventions)

Exlude a property from the EDM
- Set the `[IgnoreDataMember]`
- `employees.EntityType.Ignore(emp => emp.Salary);`

Allow/disable filter methods
- `[Queryable(PageSize=10)]`
- `[Queryable(AllowedQueryOptions=AllowedQueryOptions.Skip | AllowedQueryOptions.Top)]`
- `[Queryable(AllowedOrderByProperties="Id,Name")]`
- `[Queryable(MaxNodeCount=20)]`
- `[Queryable(AllowedFunctions= AllowedFunctions.AllFunctions & ~AllowedFunctions.All & ~AllowedFunctions.Any)]`
- `[Queryable(AllowedFunctions=AllowedFunctions.AllFunctions & ~AllowedFunctions.AllStringFunctions)]`
- 

Filtering on navigation properties can result in a join, if not indexed.

MIME type: media type. Consists of two strings, a type and a subtype.
- text/html
- image/png
- application/json

response:
```
HTTP/1.1 200 OK
Content-Length: 95267
Content-Type: image/png
```

request:
```
Accept: text/html,application/xhtml+xml,application/xml
```

Web API has built-in support for XML, JSON, BSON, and form-urlencoded data, and you can support additional media types by writing a `media formatter`.

JSON and XML formatters serialize objects.

Circular Object References
- If two properties refer to the same object, or if the same object appears twice in a collection, the formatter will serialize the object twice.
- `json.SerializerSettings.PreserveReferencesHandling` to prevent it.

BSON
- BSON is a binary serialization format. 
- stands for "Binary JSON"
- BSON and JSON are serialized very differently.
- numeric data types are stored as bytes, not strings.
- designed to be lightweight, easy to scan, and fast to encode/decode.

content negotiation
- HTTP specification (RFC 2616)
- the process of selecting the best representation for a given response when there are multiple representations available.
- Accept, Accept-Charset, Accept-Encoding, Accept-Language.

Validate rules for properties on the model
- use attributes in `System.ComponentModel.DataAnnotations`
- `Required`
- `Range(0, 999)`
- without over-posting, Web API ignore additional attributes client sents.
- to validate over-posting, create a model class that only has attributes that client is allow to send.

Web API does not automatically return an error to the client when validation fails. It is up to the controller action to check the model state and respond appropriately.

Parameter binding
- primitive types can be put in the URI, such as int, bool, double, TimeSpan, DateTime, Guid, decimal, and string. `[FromUri]`.
- complex types using a media-type formatter. `[FromBody]`.

`ExceptionFilterAttribute`: implement a `OnException` to catch unhandled exceptions. Then register it `GlobalConfiguration.Configuration.Filters.Add(new ProductStore.NotImplExceptionFilterAttribute())`.

`IExceptionLogger` and `IExceptionHandler`, to log and handle unhandled exceptions. 
- registering multiple exception loggers but only a single exception handler.
- Exception loggers always get called

Use `Microsoft.AspNet.WebApi.Tracing` to add tracking.

To write UT, use a pattern called dependency injection. Basically add interface for the real classes and create mock classes.

Web API assumes that authentication happens in the host. For web-hosting, the host is IIS, which uses HTTP modules for authentication. When the host authenticates the user, it creates a principal, which is an IPrincipal object that represents the security context under which code is running.

Instead of using the host for authentication, you can put authentication logic into an HTTP message handler. In that case, the message handler examines the HTTP request and sets the principal.
- An HTTP module sees all requests that go through the ASP.NET pipeline. A message handler only sees requests that are routed to Web API.
- You can set per-route message handlers, which lets you apply an authentication scheme to a specific route.
- HTTP modules are specific to IIS. Message handlers are host-agnostic, so they can be used with both web-hosting and self-hosting.
- HTTP modules participate in IIS logging, auditing, and so on.
- HTTP modules run earlier in the pipeline. If you handle authentication in a message handler, the principal does not get set until the handler runs. Moreover, the principal reverts back to the previous principal when the response leaves the message handler.

Web API project templates have three options for authentication
- Individual accounts. The app uses a membership database.
- Organizational accounts. Users sign in with their Azure Active Directory, Office 365, or on-premise Active Directory credentials.
- Windows authentication. This option is intended for Intranet applications, and uses the Windows Authentication IIS module.

ASP.NET 4.5.1 expand the security options for Single Page Applications (SPA) and Web API services to integrate with external authentication services, which include several OAuth/OpenID and social media authentication services: Microsoft Accounts, Twitter, Facebook, and Google.

Cross-Site Request Forgery (CSRF) is an attack where a malicious site sends a request to a vulnerable site where the user is currently logged in.

To help prevent CSRF attacks, ASP.NET MVC uses anti-forgery tokens, also called request verification tokens. Malicious page cannot read the user's tokens, due to same-origin policies. (Same-origin policies prevent documents hosted on two different sites from accessing each other's content.

CORS

HERE:
https://docs.microsoft.com/en-us/aspnet/web-api/overview/security/enabling-cross-origin-requests-in-web-api

[Filter with any](https://stackoverflow.com/questions/15475593/webapi-odata-filter-any-or-all-query-not-working)
`~/api/Blogs?$filter=Tags/any(tag: tag/Name eq 'csharp')`

https://help.nintex.com/en-us/insight/OData/HE_CON_ODATAQueryCheatSheet.htm


# Entity Framework(EF)

https://docs.microsoft.com/en-us/aspnet/entity-framework

# RESTful

https://www.tutorialspoint.com/restful/index.htm